
//
// 07/21/2018
//
// The Gigatron EEPROM is a 16 bit word, 64K word
// location EEPROM.
//
// It is async, so it does not add an extra clock delay  the Gigatron
// instruction fetch + execute loop.
//
// This version is generated using a file and the Verilog
// $readmemh statement.
//
// The Verilog data input file is generated by running the following
// Linux hexdump utility against a pure binary ROM image.
//
// hexdump -v  -e '1/2  "%04X\n"' ROMv1.rom >ROMv1_verilog_data.txt
// hexdump -v  -e '1/2  "%04X\n"' ROMv2.rom >ROMv2_verilog_data.txt
//
// Verify the number of entries generated with:
//
// wc -l ROMv1_verilog_data.txt
// wc -l ROMv2_verilog_data.txt
//
// Note for Windows users: Install Windows Linux subsystem with
// Ubuntu user mode and type "bash" to get a Linux tools
// environment. Cygwin or Altera tools will likely work as well.
//

module Gigatron_EEPROM
(
       input [15:0] address,
       output reg [15:0] data,
       input cs
);

  //
  // This infers a RAM and generates the following warnings.
  //
  // Maybe convert to an IP block to get rid of the warnings by
  // being able to specify signal defaults and which ports are enabled.
  //
  // Warning (10030): Net "reg_eeprom.data_a" at gigatron_eeprom_from_file.sv(38) has no driver or initial value, using a default initial value '0'
  //
  // Warning (10030): Net "reg_eeprom.waddr_a" at gigatron_eeprom_from_file.sv(38) has no driver or initial value, using a default initial value '0'
  //
  // Warning (10030): Net "reg_eeprom.we_a" at gigatron_eeprom_from_file.sv(38) has no driver or initial value, using a default initial value '0'
  //

  //  width             depth
  reg [15:0] reg_eeprom [0:65535];

  initial begin

    // ROMv1
//    $readmemh("application_gigatron/ROMv1_verilog_data.txt", reg_eeprom);

    // ROMv2
    //$readmemh("ROMv2_verilog_data.txt", reg_eeprom);

    // ROMv5a
    $readmemh("ROMv5a_verilog_data.txt", reg_eeprom);
  end

  always @ (cs or address) begin

    if (cs == 1'b1) begin
      data = reg_eeprom[address];
      //$display("ROM: addr: %h data:%h", address, data);
    end
    else begin
      data = 16'bz;
    end

  end // end always address

endmodule

`define tb_gigatron_eeprom_assert(signal, value) \
    if (signal !== value) begin \
	     $display("ASSERTION FAILED in %m: signal != value"); \
		  $stop; \
    end

//
// Test bench
//
module tb_gigatron_eeprom();

  reg clock_50;

  reg [15:0] address;
  reg [15:0] data;
  reg cs;
  integer i;

  // Device Under Test instance
  Gigatron_EEPROM DUT(
    .address(address),
    .data(data),
    .cs(cs)
  );

  // Set initial values
  initial begin
     clock_50 = 0;
     address = 0;
     data = 0;
     cs = 0;
  end

  //
  // Setup 50Mhz clock at 1ns resolution.
  //
  // 50mhz == 20ns period.
  // #10 delay is 1/2 of the cycle.
  //
  always #10 clock_50 = ~clock_50;

  // Stimulus to step through values
  initial begin

     cs = 1;
     @(posedge clock_50);


     $display("rdata:");

     for (i = 0; i < 16; i = i + 1) begin

       address = i;
       @(posedge clock_50);

       $display("%d:%h", i, data);

     end

     for (i = 65535 - 16; i < 65536; i = i + 1) begin

       address = i;
       @(posedge clock_50);

       $display("%d:%h", i, data);

     end

     @(posedge clock_50);
     @(posedge clock_50);

     $stop;

  end

endmodule
